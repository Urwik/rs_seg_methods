  #pragma once

// C++
#include <iostream>
#include <algorithm>
#include <filesystem>
#include <chrono>
#include <numeric>
#include <vector>
#include <random>
#include <unordered_set>


// PCL
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/features/normal_3d.h>
#include <pcl/segmentation/region_growing.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/common/common.h>
#include <pcl/common/transforms.h>
#include <pcl/common/angles.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/filter_indices.h>
#include <pcl/filters/project_inliers.h>
#include <pcl/filters/random_sample.h>
#include <pcl/filters/uniform_sampling.h>


#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/sample_consensus/sac_model_plane.h>
#include <pcl/sample_consensus/sac_model_normal_plane.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <Eigen/Dense>
#include <pcl/io/obj_io.h>

// Visualization
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/visualization/point_cloud_color_handlers.h>



namespace fs = std::filesystem;
using namespace std;

typedef pcl::PointXYZ PointT;
typedef pcl::PointCloud<PointT> PointCloud;

typedef pcl::PointXYZI PointI;
typedef pcl::PointCloud<PointI> PointCloudI;

typedef pcl::PointXYZL PointL;
typedef pcl::PointCloud<PointL> PointCloudL;

typedef pcl::PointXYZLNormal PointLN;
typedef pcl::PointCloud<PointLN> PointCloudLN;

#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"  
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"



//****************************************************************************//
// TYPE DEFINITIONS ////////////////////////////////////////////////////////////


struct metrics
{
  float precision = 0.0;
  float recall = 0.0;
  float f1_score = 0.0;
  float accuracy = 0.0;
};

struct conf_matrix
{
  int TP = 0;
  int FP = 0;
  int TN = 0;
  int FN = 0;
};

struct gt_indices
{
  pcl::IndicesPtr ground;
  pcl::IndicesPtr truss;
};

struct cm_indices
{
  pcl::IndicesPtr tp_idx;
  pcl::IndicesPtr fp_idx;
  pcl::IndicesPtr tn_idx;
  pcl::IndicesPtr fn_idx;
};


namespace arvc{

/**
 * @brief Realiza agrupaciones de puntos en función de sus normales
 * 
 * @param cloud  Nube de entrada
 * @return std::vector<pcl::PointIndices> Vector con los indices pertenecientes 
 * a cada agrupación 
 */
std::pair<vector<pcl::PointIndices>, int>
regrow_segmentation (PointCloud::Ptr &_cloud_in, pcl::IndicesPtr &_indices, bool _visualize=false)
{
  cout << "Regrow segmentation a set of indices fomr a cloud" << endl;

  auto start = std::chrono::high_resolution_clock::now();
  // Estimación de normales
  pcl::PointCloud<pcl::Normal>::Ptr _cloud_normals (new pcl::PointCloud<pcl::Normal>);
  pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
  pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
  tree->setInputCloud(_cloud_in);
  ne.setInputCloud(_cloud_in);
  // ne.setIndices(_indices);   // Tiene que estar comentado para que la dimension de _cloud_normals sea igual a _cloud_in y funcione regrow
  ne.setSearchMethod(tree);
  ne.setKSearch(30);            // Por vecinos no existen normales NaN
  // ne.setRadiusSearch(0.05);  // Por radio existiran puntos cuya normal sea NaN
  ne.compute(*_cloud_normals);
  auto stop = std::chrono::high_resolution_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);

  // Segmentación basada en crecimiento de regiones
  vector<pcl::PointIndices> _regrow_clusters;
  pcl::RegionGrowing<PointT, pcl::Normal> reg;
  reg.setMinClusterSize (50); //50 original
  reg.setMaxClusterSize (25000);
  reg.setSearchMethod (tree);
  reg.setSmoothModeFlag(false);
  reg.setCurvatureTestFlag(true);
  reg.setResidualThreshold(false);
  reg.setCurvatureThreshold(1);
  reg.setNumberOfNeighbours (10); //10 original
  reg.setInputCloud (_cloud_in);
  reg.setIndices(_indices);
  reg.setInputNormals (_cloud_normals);
  reg.setSmoothnessThreshold ( pcl::deg2rad(10.0)); //10 original
  reg.extract (_regrow_clusters);

  // RESULTS VISUALIZATION 
  if(_visualize)
  {
    pcl::visualization::PCLVisualizer vis ("Regrow Visualizer");

    int v1(0);
    int v2(0);

    vis.setBackgroundColor(1,1,1);
    try
    {
      vis.loadCameraParameters("camera_params_regrow_clusters.txt");
      /* code */
    }
    catch(const std::exception& e)
    {
    }
    

    //Define ViewPorts
    vis.createViewPort(0,0,0.5,1, v1);
    pcl::visualization::PointCloudColorHandlerCustom<PointT> green_color(_cloud_in, 10, 150, 10);
    vis.addPointCloud<PointT>(_cloud_in, green_color, "cloud", v1);
    vis.addPointCloudNormals<PointT, pcl::Normal>(_cloud_in, _cloud_normals, 5, 0.1, "normals", v1);


    vis.createViewPort(0.5,0,1,1, v2);
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr color_cloud (new pcl::PointCloud<pcl::PointXYZRGB>);
    color_cloud = reg.getColoredCloud();

    pcl::ExtractIndices<pcl::PointXYZRGB> extract;
    extract.setInputCloud(color_cloud);
    pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
    inliers->indices = *_indices;
    extract.setIndices(inliers);
    extract.setNegative(false);
    extract.filter(*color_cloud);

    vis.addPointCloud<pcl::PointXYZRGB>(color_cloud, "Regrow Segments",v2);


    while (!vis.wasStopped())
    {
      vis.saveCameraParameters("camera_params_regrow_clusters.txt");
      vis.spinOnce();
    }
  }
  return std::pair<vector<pcl::PointIndices>, int> {_regrow_clusters, duration.count()};
}



/**
 * @brief Realiza agrupaciones de puntos en función de sus normales
 * 
 * @param cloud  Nube de entrada
 * @return std::vector<pcl::PointIndices> Vector con los indices pertenecientes 
 * a cada agrupación 
 */
std::pair<vector<pcl::PointIndices>, int>
regrow_segmentation (PointCloud::Ptr &_cloud_in, bool _visualize = false)
{
  cout << "Regrow segmentation complete cloud" << endl;
  auto start = std::chrono::high_resolution_clock::now();
  // Estimación de normales
  pcl::PointCloud<pcl::Normal>::Ptr _cloud_normals (new pcl::PointCloud<pcl::Normal>);
  pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
  pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
  tree->setInputCloud(_cloud_in);
  ne.setInputCloud(_cloud_in);
  // ne.setIndices(_indices);
  ne.setSearchMethod(tree);
  ne.setKSearch(30);            // Por vecinos no existen normales NaN
  // ne.setRadiusSearch(0.05);  // Por radio existiran puntos cuya normal sea NaN
  ne.compute(*_cloud_normals);

  auto stop = std::chrono::high_resolution_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);

  // Segmentación basada en crecimiento de regiones
  vector<pcl::PointIndices> _regrow_clusters;
  pcl::RegionGrowing<PointT, pcl::Normal> reg;
  reg.setMinClusterSize (50); //50 original
  reg.setMaxClusterSize (25000);
  reg.setSearchMethod (tree);
  reg.setSmoothModeFlag(false);
  reg.setCurvatureTestFlag(true);
  reg.setResidualThreshold(false);
  reg.setCurvatureThreshold(1);
  reg.setNumberOfNeighbours (10); //10 original
  reg.setInputCloud (_cloud_in);
  reg.setInputNormals (_cloud_normals);
  reg.setSmoothnessThreshold (pcl::deg2rad(10.0)); //10 original
  reg.extract (_regrow_clusters);

  // cout << "Number of clusters: " << _regrow_clusters.size() << endl;

  if(_visualize)
  {
    pcl::visualization::PCLVisualizer vis ("Regrow Visualizer");

    int v1(0);
    int v2(0);

    //Define ViewPorts
    vis.createViewPort(0,0,0.5,1, v1);
    vis.createViewPort(0.5,0,1,1, v2);

    pcl::PointCloud<pcl::PointNormal>::Ptr cloud_pn (new pcl::PointCloud<pcl::PointNormal>);
    pcl::concatenateFields (*_cloud_in, *_cloud_normals, *cloud_pn);

    pcl::visualization::PointCloudColorHandler<pcl::PointNormal>::Ptr color_handler;
    color_handler.reset (new pcl::visualization::PointCloudColorHandlerGenericField<pcl::PointNormal> (cloud_pn, "curvature"));
    vis.addPointCloud<pcl::PointNormal>(cloud_pn, *color_handler, "asdf", v1);
    vis.addPointCloudNormals<PointT, pcl::Normal>(_cloud_in, _cloud_normals, 3, 0.1, "normals", v1);


    pcl::PointCloud<pcl::PointXYZRGB>::Ptr color_cloud (new pcl::PointCloud<pcl::PointXYZRGB>);
    color_cloud = reg.getColoredCloud();
    vis.addPointCloud<pcl::PointXYZRGB>(color_cloud, "Regrow Segments",v2);

    while (!vis.wasStopped())
      vis.spinOnce();
  }

  return std::pair<vector<pcl::PointIndices>, int> {_regrow_clusters, duration.count()};
}


/**
 * @brief Filtra la nube de puntos en función de los índices pasados como parámetro
 * 
 * @param cloud Nube de entrada
 * @param indices_vec Vector con los índices de los puntos que se quieren extraer
 * @param negative Si es true, se extraen los puntos que no están en indx_vec
 */
PointCloud::Ptr
extract_indices(PointCloud::Ptr &cloud, std::vector<pcl::PointIndices> indices_vec, bool negative = false)
{
  pcl::PointIndices::Ptr indices (new pcl::PointIndices);
  PointCloud::Ptr _cloud_out (new PointCloud);

  for (size_t i = 0; i < indices_vec.size(); i++)
    for(auto index : indices_vec[i].indices)
      indices->indices.push_back(index);
  
  pcl::ExtractIndices<PointT> extract;
  extract.setInputCloud(cloud);
  extract.setIndices(indices);
  extract.setNegative(negative);
  extract.filter(*_cloud_out);

  return _cloud_out;
}



/**
 * @brief Filtra la nube de puntos en función de los índices pasados como parámetro
 * 
 * @param cloud Nube de entrada
 * @param indices Indices de los puntos que se quieren extraer
 * @param negative Si es true, se extraen los puntos que no están en indx_vec
 */
PointCloud::Ptr
extract_indices (PointCloud::Ptr &_cloud_in, pcl::IndicesPtr &_indices, bool negative = false)
{
  PointCloud::Ptr _cloud_out (new PointCloud);
  pcl::ExtractIndices<PointT> extract;
  extract.setInputCloud(_cloud_in);
  extract.setIndices(_indices);
  extract.setNegative(negative);
  extract.filter(*_cloud_out);

  return _cloud_out;
}


/**
 * @brief Filtra la nube de puntos en función de los índices pasados como parámetro
 * 
 * @param cloud 
 * @param optimizeCoefs 
 * @param distThreshold 
 * @param maxIterations 
 * @return pcl::ModelCoefficients::Ptr 
 */
pcl::ModelCoefficientsPtr 
compute_planar_ransac (PointCloud::Ptr &_cloud_in, const bool optimizeCoefs,
            float distThreshold = 0.03, int maxIterations = 1000)
{
  pcl::PointIndices point_indices;
  pcl::SACSegmentation<PointT> ransac;
  pcl::ModelCoefficientsPtr plane_coeffs (new pcl::ModelCoefficients);

  ransac.setInputCloud(_cloud_in);
  ransac.setOptimizeCoefficients(optimizeCoefs);
  ransac.setModelType(pcl::SACMODEL_PLANE);
  ransac.setMethodType(pcl::SAC_RANSAC);
  ransac.setMaxIterations(maxIterations);
  ransac.setDistanceThreshold(distThreshold);
  ransac.segment(point_indices, *plane_coeffs);

  return plane_coeffs;
}

pcl::ModelCoefficientsPtr 
compute_planar_ransac (PointCloud::Ptr &_cloud_in, const pcl::PointIndicesPtr& _indices, const bool optimizeCoefs=true,
            float distThreshold = 0.02, int maxIterations = 1000)
{
  pcl::PointIndices point_indices;
  pcl::SACSegmentation<PointT> ransac;
  pcl::ModelCoefficientsPtr plane_coeffs (new pcl::ModelCoefficients);

  ransac.setInputCloud(_cloud_in);
  ransac.setIndices(_indices);
  ransac.setOptimizeCoefficients(optimizeCoefs);
  ransac.setModelType(pcl::SACMODEL_PLANE);
  ransac.setMethodType(pcl::SAC_RANSAC);
  ransac.setMaxIterations(maxIterations);
  ransac.setDistanceThreshold(distThreshold);
  ransac.segment(point_indices, *plane_coeffs);

  return plane_coeffs;
}

pcl::ModelCoefficientsPtr 
compute_planar_ransac_direction (PointCloud::Ptr &_cloud_in, const pcl::PointIndicesPtr& _indices, const bool optimizeCoefs=true,
            float distThreshold = 0.02, int maxIterations = 1000, float angleThreshold = 5.0, Eigen::Vector3f _direction = Eigen::Vector3f(0,0,1))
{
  pcl::PointIndices point_indices;
  pcl::SACSegmentation<PointT> ransac;
  pcl::ModelCoefficientsPtr plane_coeffs (new pcl::ModelCoefficients);

  ransac.setInputCloud(_cloud_in);
  ransac.setIndices(_indices);
  ransac.setOptimizeCoefficients(optimizeCoefs);
  ransac.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
  ransac.setMethodType(pcl::SAC_RANSAC);
  ransac.setMaxIterations(maxIterations);
  ransac.setDistanceThreshold(distThreshold);
  ransac.setAxis(_direction);
  ransac.setEpsAngle (pcl::deg2rad (angleThreshold));
  ransac.segment(point_indices, *plane_coeffs);

  return plane_coeffs;
}

/**
 * @brief Filtra la nube de puntos en función de los índices pasados como parámetro
 * 
 * @param cloud 
 * @param coefs 
 * @param distThreshold 
 * @return pcl::PointIndices::Ptr 
 */
pair<pcl::IndicesPtr, pcl::IndicesPtr>
get_points_near_plane(PointCloud::Ptr &_cloud_in, pcl::ModelCoefficientsPtr &_plane_coeffs, float distThreshold = 0.5f)
{
  Eigen::Vector4f coefficients(_plane_coeffs->values.data());
  pcl::PointXYZ point;
  pcl::IndicesPtr _plane_inliers (new pcl::Indices);
  pcl::IndicesPtr _plane_outliers (new pcl::Indices);

  for (size_t indx = 0; indx < _cloud_in->points.size(); indx++)
  {
    point = _cloud_in->points[indx];
    float distance = pcl::pointToPlaneDistance(point, coefficients);
    if (pcl::pointToPlaneDistance(point, coefficients) <= distThreshold)
      _plane_inliers->push_back(indx);
    else
      _plane_outliers->push_back(indx);
  }

  return pair<pcl::IndicesPtr, pcl::IndicesPtr> {_plane_inliers, _plane_outliers};
}


/**
 * @brief Filtra la nube de puntos en función de los índices pasados como parámetro
 * 
 * @param cloud 
 * @param coefs 
 * @param distThreshold 
 * @return pcl::PointIndices::Ptr 
 */
pair<pcl::IndicesPtr, pcl::IndicesPtr>
get_points_near_plane(PointCloud::Ptr &_cloud_in, pcl::IndicesPtr &_indices, pcl::ModelCoefficientsPtr &_plane_coeffs, float distThreshold = 0.5f)
{
  Eigen::Vector4f coefficients(_plane_coeffs->values.data());
  pcl::PointXYZ point;
  pcl::IndicesPtr _plane_inliers (new pcl::Indices);
  pcl::IndicesPtr _plane_outliers (new pcl::Indices);


  // PointCloud::Ptr _cloud_out (new PointCloud);
  // pcl::ExtractIndices<PointT> extract;
  // extract.setInputCloud(_cloud_in);
  // extract.setIndices(_indices);
  // extract.setNegative(negative);
  // extract.filter(*_cloud_out);

  for (int indx : *_indices)
  {
    point = _cloud_in->points[indx];
    float distance = pcl::pointToPlaneDistance(point, coefficients);
    if (pcl::pointToPlaneDistance(point, coefficients) <= distThreshold)
      _plane_inliers->push_back(indx);
    else
      _plane_outliers->push_back(indx);
  }

  return pair<pcl::IndicesPtr, pcl::IndicesPtr> {_plane_inliers, _plane_outliers};
}


/**
 * @brief Computes the eigenvalues of a PointCloud
 * 
 * @param cloud_in 
 * @return Eigen::Vector3f 
 */
Eigen::Vector3f
compute_eigenvalues(PointCloud::Ptr &_cloud_in, pcl::IndicesPtr &_indices, bool normalize = true)
{
  Eigen::Vector4f xyz_centroid;
  PointCloud::Ptr tmp_cloud (new PointCloud);
  tmp_cloud = arvc::extract_indices(_cloud_in, _indices);
  pcl::compute3DCentroid(*tmp_cloud, xyz_centroid);

  Eigen::Matrix3f covariance_matrix;
  if (normalize)
    pcl::computeCovarianceMatrixNormalized (*tmp_cloud, xyz_centroid, covariance_matrix); 
  else
    pcl::computeCovarianceMatrix (*tmp_cloud, xyz_centroid, covariance_matrix); 

  Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> eigen_solver(covariance_matrix, Eigen::ComputeEigenvectors);
  Eigen::Vector3f eigenValuesPCA = eigen_solver.eigenvalues();

  return eigenValuesPCA;
}

struct eig_decomp
{
  Eigen::Vector3f values;
  Eigen::Matrix3f vectors;
};

eig_decomp
compute_eigen_decomposition(PointCloud::Ptr &_cloud_in, pcl::IndicesPtr &_indices, bool normalize = true)
{
  Eigen::Vector4f xyz_centroid;
  PointCloud::Ptr tmp_cloud (new PointCloud);
  tmp_cloud = arvc::extract_indices(_cloud_in, _indices);
  pcl::compute3DCentroid(*tmp_cloud, xyz_centroid);

  Eigen::Matrix3f covariance_matrix;
  if (normalize)
    pcl::computeCovarianceMatrixNormalized (*tmp_cloud, xyz_centroid, covariance_matrix); 
  else
    pcl::computeCovarianceMatrix (*tmp_cloud, xyz_centroid, covariance_matrix); 

  Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> eigen_solver(covariance_matrix, Eigen::ComputeEigenvectors);

  eig_decomp eigen_decomp;
  eigen_decomp.values = eigen_solver.eigenvalues();
  eigen_decomp.vectors = eigen_solver.eigenvectors();

  return eigen_decomp;
}


} // namespace arvc